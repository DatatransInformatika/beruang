import{dedupingMixin}from"../../../@polymer/polymer/lib/utils/mixin.js";import{FlattenedNodesObserver}from"../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js";import{afterNextRender}from"../../../@polymer/polymer/lib/utils/render-status.js";import*as Gestures from"../../../@polymer/polymer/lib/utils/gestures.js";/**
`BrownTabBehavior`
@polymerBehavior BrownTabBehavior
*/let internalBrownTabBehavior=base=>class extends base{static get properties(){return{dynamicTab:{type:Boolean,value:!1,reflectToAttribute:!0}}}ready(){super.ready();Gestures.addListener(this,"tap",e=>{//v
let path=e.path||e.composedPath&&e.composedPath(),tabItem=this._tabItem(path);if(!tabItem){//tap bukan berasal dari tabtItem, return cepat
return}let closing="tab-closer"==path[0].id;//apakah closing?
if(closing){this._onTabClosing(tabItem)}else{if(tabItem.active){//tabItem sudah berstatus aktif
return;//tidak perlu mengaktifkan tabItem
}this._onTabActiving(tabItem)}});this.addEventListener("active-changed",e=>{//v
this._onTabActiveChanged(e.target,e.detail.active)});////memantau perubahan dalam #header-slot untuk perlu-tidaknya tab-item scroll ditampilkan
let slot=this.shadowRoot.querySelector("#header-slot"),fMonitorCallback=info=>{//FlattenedNodesObserver memantau slot
if(0<info.addedNodes.length||0<info.removedNodes.length){//jika tab item ditambah atau dihapus
let f=function(){//beri waktu posisi tab item stabil
this._evaluateScroll();//perlu tampil scroll kanan, kiri, atau dua-duanya
};afterNextRender(this,f)}};//slot -> slot name:header-slot//v
this._observer=new FlattenedNodesObserver(slot,fMonitorCallback)}//ready()
connectedCallback(){super.connectedCallback();this._fWndResize=this._fWndResize||this._evaluateScroll.bind(this);window.addEventListener("resize",this._fWndResize)}disconnectedCallback(){super.disconnectedCallback();window.removeEventListener("resize",this._fWndResize)}_tabItem(path){for(let i=0;i<path.length;i++){if("BROWN-TABITEM-DESKTOP"==path[i].nodeName){return path[i]}}return null}////////////////////////fungsi untuk menggeser tab lain (next / previous), jika suatu tab ditutup:START/////////////
_getTabItemSibling(el/*tab item*/,callback/*fungsi berisi syarat pencarian*/){//v
let f=sib=>{return"BROWN-TABITEM-DESKTOP"==sib.nodeName&&(//syarat 1: sibling harus <brown-tab-desktop></brown-tab-desktop>
!callback||callback(sib));//syarat 2: jika tidak ada callback atau
//callback return true, maka sibling memenuhi syarat
},sibling=this._getLightDOM(el.nextElementSibling,!0,f);//forward
if(!sibling){sibling=this._getLightDOM(el.previousElementSibling,!1,f);//backward
}return sibling}//_getTabItemSibling(el, callback)
////////////////////////fungsi untuk menggeser tab lain (next / previous), jika suatu tab ditutup:END/////////////
_getLightDOM(startEl,forward,callback){//v
let el=startEl;while(el){if(callback(el)){//x
return el;//x
}el=forward?el.nextElementSibling:el.previousElementSibling}return null}//header item scrolling:BEGIN
_ensureItemVisible(tabItem){//v
let container=this.shadowRoot.querySelector("#header-item"),right=tabItem.offsetLeft+tabItem.offsetWidth-container.scrollLeft,left=tabItem.offsetLeft-container.scrollLeft,scroll=0;if(right>container.offsetWidth){scroll=right-container.offsetWidth}else if(0>left){scroll=left}if(0!=scroll){container.scrollLeft+=scroll;this._evaluateScroll()}}_evaluateScroll(){//v
setTimeout(()=>{this._evaluateScrollDo("#post-scroll");this._evaluateScrollDo("#pre-scroll")},100)}_evaluateScrollDo(scrollerId){//v
let container=this.shadowRoot.querySelector("#header-item"),scroller=this.shadowRoot.querySelector(scrollerId),visible=!1;if("#post-scroll"==scrollerId){//_getLightDOM(startEl, forward, callback)
let tabItem=this._getLightDOM(this.lastElementChild,!1,el=>{//get last tabItem
return"BROWN-TABITEM-DESKTOP"==el.nodeName});if(tabItem){let right=tabItem.offsetLeft+tabItem.offsetWidth-container.scrollLeft;visible=right>container.offsetWidth}}else if("#pre-scroll"==scrollerId){let tabItem=this._getLightDOM(this.firstElementChild,!0,el=>{//get first tabItem
return"BROWN-TABITEM-DESKTOP"==el.nodeName});if(tabItem){let left=tabItem.offsetLeft-container.scrollLeft;visible=0>left}}if(visible){scroller.classList.add("scroll")}else{scroller.classList.remove("scroll")}}//_evaluateScrollDo(scrollerId)
_preScroll(e){//v
let tabItem=this._getLightDOM(this.firstElementChild,!0,el=>{//search first tabItem
return"BROWN-TABITEM-DESKTOP"==el.nodeName});if(tabItem){let container=this.shadowRoot.querySelector("#header-item"),offset=tabItem.offsetLeft-container.scrollLeft;if(0>offset){offset=Math.max(offset,-1*(container.offsetWidth/5));container.scrollLeft+=offset;this._evaluateScroll();//selesai scroll, diperiksa masih butuh scroll atau tidak
}}}_postScroll(e){//v
let tabItem=this._getLightDOM(this.lastElementChild,!1,el=>{//search last tabItem
return"BROWN-TABITEM-DESKTOP"==el.nodeName});if(tabItem){let container=this.shadowRoot.querySelector("#header-item"),right=tabItem.offsetLeft+tabItem.offsetWidth-container.scrollLeft,offset=right-container.offsetWidth;if(0<offset){offset=Math.min(offset,container.offsetWidth/5);container.scrollLeft+=offset;this._evaluateScroll();//selesai scroll, diperiksa masih butuh scroll atau tidak
}}}//header item scrolling:END
_onTabClosing(tabItem){throw new ReferenceError("_onTabClosing must be implemented by child class")}_onTabActiving(tabItem){throw new ReferenceError("_onTabActiving must be implemented by child class")}_onTabActiveChanged(tabItem,active){throw new ReferenceError("_onTabActiveChanged must be implemented by child class")}};export const BrownTabBehavior=dedupingMixin(internalBrownTabBehavior);