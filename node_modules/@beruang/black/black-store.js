/**
@license
Copyright (c) 2019 The Beruang Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
https://github.com/DatatransInformatika/beruang/blob/master/LICENSE.txt The complete set of authors may be found at
https://github.com/DatatransInformatika/beruang/blob/master/AUTHORS.txt The complete set of contributors may be
found at https://github.com/DatatransInformatika/beruang/blob/master/CONTRIBUTORS.txt
*/
import {html, PolymerElement} from '@polymer/polymer/polymer-element.js';
import {FlattenedNodesObserver} from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';

class BlackStore extends PolymerElement {
  static get template() {
    return html`
      <style>
        :host {
          display:none;
        }
      </style>
      <slot name="tuple"></slot>
    `;
  }

  static get properties() {
      return {
          key: {
              type:String
          },

          recordset: {
              type:Array,
              value: function() { return []; },
              readOnly:true
          }
      };
  }

  ready() {
      super.ready();

      let slot = this.shadowRoot.querySelector("slot");
      let fMonitorCallback = (info) => {
          let i;

          let primaryValueArr = this._primaryValueArray();

          for(i=0; i<info.addedNodes.length; i++) {
              let el = info.addedNodes[i];
              let primaryValue = this._checkTuple(el.obj, primaryValueArr);
              primaryValueArr.push(  primaryValue );
              let record = this._createRecord(el.obj);
              this.push("recordset", record);
          }

          //menghapus records
          for(i=0; i<info.removedNodes.length; i++) {
              let el = info.removedNodes[i];
              let primaryValue = el.obj[this.key];
              let index = this._recordIndex(primaryValue);
              if(index>=0) {
                  this.splice("recordset", index, 1);
              }
          }
      };
      this._observer = new FlattenedNodesObserver(slot, fMonitorCallback);
  }

  addTuple(index, tuple) {
      let primaryValueArr = this._primaryValueArray();
      this._checkTuple(tuple, primaryValueArr);
      let record = this._createRecord(tuple);
      let recordLen = this.recordset.length;
      if(index<0 || index>=recordLen) {
          this.push("recordset", record);
      } else {
          this.splice("recordset", index, 0, record);
      }
  }

  _createRecord(tuple) {
      return {
          "tuple":tuple,
          "changeset":{}
      };
  }

  _recordIndex(primaryValue) {
      let index = -1;
      for(let i=0; i<this.recordset.length; i++) {
          let record = this.recordset[i];
          let value = this._recordValue(record, this.key);
          if(primaryValue == value) {
              index = i;
              break;
          }
      }
      return index;
  }

  _recordValue(record, key) {
      return record.changeset.hasOwnProperty(key) ? record.changeset[key] : record.tuple[key];
  }

  _checkTuple(tuple, primaryValueArr) {
      if( !tuple.hasOwnProperty(this.key) ) {
          throw new ReferenceError("tuple must have key property [" + this.key + "]");
      }
      let primaryValue = tuple[this.key];
      let index = primaryValueArr.indexOf( primaryValue );
      if( index>=0 ) {
          throw new ReferenceError("duplicate primary value [" + primaryValue + "]");
      }
      return primaryValue;
  }

  _primaryValueArray() {
      let primaryValueArr = [];
      for(let i=0; i<this.recordset.length; i++) {
          let value = this._recordValue(this.recordset[i], this.key);
          primaryValueArr.push(  value );
      }
      return primaryValueArr;
  }
}

window.customElements.define('black-store', BlackStore);
