/**
@license
Copyright (c) 2019 The Beruang Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
https://github.com/DatatransInformatika/beruang/blob/master/LICENSE.txt The complete set of authors may be found at
https://github.com/DatatransInformatika/beruang/blob/master/AUTHORS.txt The complete set of contributors may be
found at https://github.com/DatatransInformatika/beruang/blob/master/CONTRIBUTORS.txt
*/
import {html, PolymerElement} from '@polymer/polymer/polymer-element.js';
import {FlattenedNodesObserver} from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';

class BlackStore extends PolymerElement {
  static get template() {
    return html`
      <style>
        :host {
          display:none;
        }
      </style>
      <slot name="tuple"></slot>
    `;
  }

  static get properties() {
      return {
          key: {
              type:String
          },

          recordset: {
              type:Array,
              value: function() { return []; },
              readOnly:true
          }
      };
  }

  ready() {
      super.ready();

      let slot = this.shadowRoot.querySelector("slot");
      let fMonitorCallback = (info) => {
          let i;

          let primaryValueArr = this._primaryValueArray();

          for(i=0; i<info.addedNodes.length; i++) {
              let el = info.addedNodes[i];
              let primaryValue = this._checkTuple(el.obj, primaryValueArr);
              primaryValueArr.push(  primaryValue );
              let record = this._createRecord(el.obj);
              this.push("recordset", record);
          }

          //menghapus records
          for(i=0; i<info.removedNodes.length; i++) {
              let el = info.removedNodes[i];
              let primaryValue = el.obj[this.key];
              let index = this._recordIndex(primaryValue);
              if(index>=0) {
                  this.splice("recordset", index, 1);
              }
          }
      };
      this._observer = new FlattenedNodesObserver(slot, fMonitorCallback);
  }

  addTuple(index, tuple) {
      let primaryValueArr = this._primaryValueArray();
      let recordLen = this.recordset.length;
      this._addTuple(index, tuple, primaryValueArr, recordLen);
  }

  addTuples(index, tuples) {
      let primaryValueArr = this._primaryValueArray();
      let recordLen = this.recordset.length;
      for(let i=0; i<tuples.length; i++) {
          let primaryValue = this._addTuple(index++, tuples[i], primaryValueArr, recordLen++);
          primaryValueArr.push(primaryValue);
      }
  }

  removeTuple(id) {
    let index = this._recordIndex(id);
    if( index>=0 ) {
        this.splice("recordset", index, 1);
    }
  }

  removeTuples(ids) {
      for(let i=0; i<ids.length; i++) {
        this.removeTuple(ids[i]);
      }
  }

  sortTuples(fSort) {
      //this.recordset.sort(fSort);
      let len = this.recordset.length;
      for(let i=0; i<len-1; i++) {

          let championIndex = i;
          let championRecord = this.recordset[i];
          let championTuple = this._mergeTuple(championRecord);

          let challengerIndex = i+1;
          let challengerRecord = this.recordset[i+1];
          let challengerTuple = this._mergeTuple(challengerRecord);
          for(let j = i+2; j<len; j++) {
            let record = this.recordset[j];
            let tuple = this._mergeTuple(record);
            if( fSort(challengerTuple, tuple) > 0 ) {
                challengerIndex = j;
                challengerRecord = record;
                challengerTuple = this._mergeTuple(record);
            }
          }

          if( fSort(championTuple, challengerTuple) > 0 ) {
              this.recordset[championIndex] = challengerRecord;
              this.recordset[challengerIndex] = championRecord;
          }
      }

      this.notifyPath("recordset");
  }

  _addTuple(index, tuple, primaryValueArr, recordLen) {
      let primaryValue = this._checkTuple(tuple, primaryValueArr);
      let record = this._createRecord(tuple);
      if(index<0 || index>=recordLen) {
          this.push("recordset", record);
      } else {
          this.splice("recordset", index, 0, record);
      }
      return primaryValue;
  }

  _createRecord(tuple) {
      return {
          "tuple":tuple,
          "changeset":{}
      };
  }

  _recordIndex(primaryValue) {
      let index = -1;
      for(let i=0; i<this.recordset.length; i++) {
          let record = this.recordset[i];
          let value = this._recordValue(record, this.key);
          if(primaryValue == value) {
              index = i;
              break;
          }
      }
      return index;
  }

  _recordValue(record, key) {
      return record.changeset.hasOwnProperty(key) ? record.changeset[key] : record.tuple[key];
  }

  _mergeTuple(record) {
      let ks = Object.keys(record.tuple);
      let tuple = {};
      for(let i=0; i<ks.length; i++) {
          let k = ks[i];
          tuple[k] = this._recordValue(record, k);
      }
      return tuple;
  }

  _checkTuple(tuple, primaryValueArr) {
      if( !tuple.hasOwnProperty(this.key) ) {
          throw new ReferenceError("tuple must have key property [" + this.key + "]");
      }
      let primaryValue = tuple[this.key];
      let index = primaryValueArr.indexOf( primaryValue );
      if( index>=0 ) {
          throw new ReferenceError("duplicate primary value [" + primaryValue + "]");
      }
      return primaryValue;
  }

  _primaryValueArray() {
      let primaryValueArr = [];
      for(let i=0; i<this.recordset.length; i++) {
          let value = this._recordValue(this.recordset[i], this.key);
          primaryValueArr.push(  value );
      }
      return primaryValueArr;
  }
}

window.customElements.define('black-store', BlackStore);
