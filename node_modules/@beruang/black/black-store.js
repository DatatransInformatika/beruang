/**
@license
Copyright (c) 2019 The Beruang Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
https://github.com/DatatransInformatika/beruang/blob/master/LICENSE.txt The complete set of authors may be found at
https://github.com/DatatransInformatika/beruang/blob/master/AUTHORS.txt The complete set of contributors may be
found at https://github.com/DatatransInformatika/beruang/blob/master/CONTRIBUTORS.txt
*/
import {html, PolymerElement} from '@polymer/polymer/polymer-element.js';
import {FlattenedNodesObserver} from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';

class BlackStore extends PolymerElement {
  static get template() {
    return html`
      <style>
        :host {
          display:none;
        }
      </style>
      <slot name="tuple"></slot>
    `;
  }

  static get properties() {
      return {
          key: {
              type:String
          },

          tuples: {
              type:Array,
              value: function() { return []; }
          }
      };
  }

  ready() {
      super.ready();

      let slot = this.shadowRoot.querySelector("slot");
      let fMonitorCallback = (info) => {
          let i, j;

          let primaryValueArr = [];
          for(i=0; i<this.tuples; i++) {
              let value = this.tuples[i][this.key];
              primaryValueArr.push(  value );
          }

          for(i=0; i<info.addedNodes.length; i++) {
              let el = info.addedNodes[i];

              if( !el.obj.hasOwnProperty(this.key) ) {
                  throw new ReferenceError("tuple must have key property [" + this.key + "]");
              }
              let primaryValue = el.obj[this.key];
              let index = primaryValueArr.indexOf( primaryValue );
              if( index>=0 ) {
                  throw new ReferenceError("duplicate primary value [" + primaryValue + "]");
              }
              primaryValueArr.push(  primaryValue );

              this.push("tuples", el.obj);
          }

          for(i=0; i<info.removedNodes.length; i++) {
              let el = info.removedNodes[i];
              let index = this.tuples.indexOf(el.obj);
              if(index>=0) {
                  this.splice("tuples", index, 1);
              }
          }
      };
      this._observer = new FlattenedNodesObserver(slot, fMonitorCallback);
  }
}

window.customElements.define('black-store', BlackStore);
