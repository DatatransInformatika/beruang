export class Record {
    constructor(tuple) {
        this.tuple = tuple;
        this.changeset = {};
    }

    getValue(key) {
        this._verifyKey(key);
        return this.changeset.hasOwnProperty(key) ? this.changeset[key] : this.tuple[key];
    }

    setValue(key, value) {
        this._verifyKey(key);
        if( value == this.tuple[key]) {
            delete this.changeset[key];
        } else  {
            this.changeset[key] = value;
        }
    }

    commit() {
        let ks = Object.keys(this.changeset);
        for(let i=0; i<ks.length; i++) {
            this._commitValue( ks[i] );
        }
    }

    commitValue(key) {
        if( this.isKeyDirty(key) ) {
            this._commitValue(key);
        }
    }

    rollback() {
        let ks = Object.keys(this.changeset);
        for(let i=0; i<ks.length; i++) {
            this._rollbackValue( ks[i] );
        }
    }

    rollbackValue(key) {
        if( this.isKeyDirty(key) ) {
            this._rollbackValue(key);
        }
    }

    isDirty() {
        let ks = Object.keys(this.changeset);
        return ks.length > 0;
    }

    isKeyDirty(key) {
        return this.changeset.hasOwnProperty(key);
    }

    _commitValue(key) {
        this.tuple[key] = this.changeset[key];
        delete this.changeset[key];
    }

    _rollbackValue(key) {
        delete this.changeset[key];
    }

    mergeTuple() {
        let ks = Object.keys(this.tuple);
        let tuple = {};
        for(let i=0; i<ks.length; i++) {
            tuple[ ks[i] ] = this.getValue( ks[i] );
        }
        return tuple;
    }

    _verifyKey(key) {
        if( !this.tuple.hasOwnProperty(key) ) {
            throw new ReferenceError("invalid key [" + key + "]");
        }
    }
}
