/**
@license
Copyright (c) 2019 The Beruang Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
https://github.com/DatatransInformatika/beruang/blob/master/LICENSE.txt The complete set of authors may be found at
https://github.com/DatatransInformatika/beruang/blob/master/AUTHORS.txt The complete set of contributors may be
found at https://github.com/DatatransInformatika/beruang/blob/master/CONTRIBUTORS.txt
*/
import {dedupingMixin} from '@polymer/polymer/lib/utils/mixin.js';
import {FlattenedNodesObserver} from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';
import {afterNextRender} from '@polymer/polymer/lib/utils/render-status.js';
import * as Gestures from '@polymer/polymer/lib/utils/gestures.js';

/**
`BrownTabBehavior`
@polymerBehavior BrownTabBehavior
*/
let internalBrownTabBehavior = (base) =>
class extends base {
	static get properties() {
		return {
			dynamicTab: {
				type:Boolean,
				value:false,
				reflectToAttribute:true
			}
    	};
	}

	ready() {
		super.ready();

		Gestures.addListener(this, "tap", (e)=>{//v
			let path = e.path || (e.composedPath && e.composedPath());
			let tabItem = this._tabItem(path);
			if( !tabItem ) {//tap bukan berasal dari tabtItem, return cepat
				return;
			}

			let closing = path[0].id=="tab-closer";//apakah closing?
			if(closing) {
				this._onTabClosing(tabItem);
			} else {
				if( tabItem.active ) {//tabItem sudah berstatus aktif
					return;//tidak perlu mengaktifkan tabItem
				}
				this._onTabActiving(tabItem);
			}
		});

		this.addEventListener("active-changed", (e)=>{//v
			this._onTabActiveChanged(e.target, e.detail.active);
		});

	////memantau perubahan dalam #header-slot untuk perlu-tidaknya tab-item scroll ditampilkan
		let slot = this.shadowRoot.querySelector("#header-slot");//slot -> slot name:header-slot//v
		let fMonitorCallback = (info) => {//FlattenedNodesObserver memantau slot
		  if(info.addedNodes.length>0 || info.removedNodes.length>0) { //jika tab item ditambah atau dihapus
			let f = function() {//beri waktu posisi tab item stabil
			  this._evaluateScroll();//perlu tampil scroll kanan, kiri, atau dua-duanya
			};
			afterNextRender(this, f);
		  }
		};
		this._observer = new FlattenedNodesObserver(slot, fMonitorCallback);
	}//ready()

	connectedCallback() {
		super.connectedCallback();
		this._fWndResize = this._fWndResize || this._evaluateScroll.bind(this);
		window.addEventListener("resize", this._fWndResize);
	}

	disconnectedCallback() {
		super.disconnectedCallback();
		window.removeEventListener("resize", this._fWndResize);
	}

	_tabItem(path) {
		for(let i=0;i<path.length;i++) {
			if(path[i].nodeName=="BROWN-TABITEM-DESKTOP") {
				return path[i];
			}
		}
		return null;
	}

	////////////////////////fungsi untuk menggeser tab lain (next / previous), jika suatu tab ditutup:START/////////////
	_getTabItemSibling(el/*tab item*/, callback/*fungsi berisi syarat pencarian*/) {//v
		let f = (sib)=>{
			return sib.nodeName=="BROWN-TABITEM-DESKTOP" && //syarat 1: sibling harus <brown-tab-desktop></brown-tab-desktop>
				( !callback || callback(sib) ); //syarat 2: jika tidak ada callback atau
	                                                  //callback return true, maka sibling memenuhi syarat
		};
		let sibling = this._getLightDOM(el.nextElementSibling, true, f); //forward
		if(!sibling) {
			sibling = this._getLightDOM(el.previousElementSibling, false, f); //backward
		}
		return sibling;
	}//_getTabItemSibling(el, callback)
	////////////////////////fungsi untuk menggeser tab lain (next / previous), jika suatu tab ditutup:END/////////////

	_getLightDOM(startEl, forward, callback) {//v
		let el = startEl;
		while(el) {
			if(callback(el)) {//x
				return el;//x
			}
			el = forward ? el.nextElementSibling : el.previousElementSibling;
		}
		return null;
	}

//header item scrolling:BEGIN
	_ensureItemVisible(tabItem) {//v
		let container = this.shadowRoot.querySelector("#header-item");
		let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
		let left = tabItem.offsetLeft - container.scrollLeft;
		let scroll = 0;
		if( right > container.offsetWidth ) {
			scroll = right - container.offsetWidth;
		} else if( left<0 ) {
			scroll = left;
		}
		if(scroll!=0) {
			container.scrollLeft += scroll;
			this._evaluateScroll();
		}
	}

	_evaluateScroll() {//v
		setTimeout( ()=>{
			this._evaluateScrollDo("#post-scroll");
			this._evaluateScrollDo("#pre-scroll");
		}, 100);
	}

	_evaluateScrollDo(scrollerId) {//v
		let container = this.shadowRoot.querySelector("#header-item");
		let scroller = this.shadowRoot.querySelector(scrollerId);
		let visible = false;
		if(scrollerId=="#post-scroll") {
			//_getLightDOM(startEl, forward, callback)
			let tabItem = this._getLightDOM(this.lastElementChild, false, (el)=>{//get last tabItem
				return el.nodeName=="BROWN-TABITEM-DESKTOP";
			});
			if(tabItem) {
				let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
				visible = right > container.offsetWidth;
			}
		} else if(scrollerId=="#pre-scroll") {
			let tabItem = this._getLightDOM(this.firstElementChild, true, (el)=>{//get first tabItem
				return el.nodeName=="BROWN-TABITEM-DESKTOP";
			});
			if(tabItem) {
				let left = tabItem.offsetLeft - container.scrollLeft;
				visible = left < 0;
			}
		}
		if(visible) {
			scroller.classList.add("scroll");
		} else {
			scroller.classList.remove("scroll");
		}
	}//_evaluateScrollDo(scrollerId)

	_preScroll(e) {//v
		let tabItem = this._getLightDOM(this.firstElementChild, true, (el)=>{//search first tabItem
			return el.nodeName=="BROWN-TABITEM-DESKTOP";
		});
		if(tabItem) {
			let container = this.shadowRoot.querySelector("#header-item");
			let offset = tabItem.offsetLeft - container.scrollLeft;
			if( offset<0 ) {
				offset = Math.max(offset, -1 * (container.offsetWidth/5));
				container.scrollLeft += offset;
				this._evaluateScroll();//selesai scroll, diperiksa masih butuh scroll atau tidak
			}
		}
	}

	_postScroll(e) {//v
		let tabItem = this._getLightDOM(this.lastElementChild, false, (el)=>{//search last tabItem
			return el.nodeName=="BROWN-TABITEM-DESKTOP";
		});
		if(tabItem) {
			let container = this.shadowRoot.querySelector("#header-item");
			let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
			let offset = right - container.offsetWidth;
			if( offset>0 ) {
				offset = Math.min(offset, container.offsetWidth/5);
				container.scrollLeft += offset;
				this._evaluateScroll();//selesai scroll, diperiksa masih butuh scroll atau tidak
			}
		}
	}
//header item scrolling:END

	_onTabClosing(tabItem) {
		throw new ReferenceError('_onTabClosing must be implemented by child class');
	}

	_onTabActiving(tabItem){
		throw new ReferenceError('_onTabActiving must be implemented by child class');
	}

	_onTabActiveChanged(tabItem, active) {
		throw new ReferenceError('_onTabActiveChanged must be implemented by child class');
	}
}

export const BrownTabBehavior = dedupingMixin(internalBrownTabBehavior);
