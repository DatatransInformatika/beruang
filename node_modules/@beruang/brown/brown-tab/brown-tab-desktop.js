import {html, PolymerElement} from '@polymer/polymer/polymer-element.js';
import {GestureEventListeners} from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';
import {FlattenedNodesObserver} from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';
import {afterNextRender} from '@polymer/polymer/lib/utils/render-status.js';
import * as Gestures from '@polymer/polymer/lib/utils/gestures.js';
import '@polymer/iron-flex-layout/iron-flex-layout.js';
import '@webcomponents/shadycss/entrypoints/apply-shim.js';
import {BeruangBehavior} from '@beruang/beruang-behavior.js';
import {BrownBehavior} from '@beruang/brown/brown-behavior.js';
import '@beruang/brown/brown-style.js';

class BrownTabDesktop extends BrownBehavior(BeruangBehavior(GestureEventListeners(PolymerElement))) {
  static get template() {
    return html`
      <style  include="brown-style">
        :host {
          @apply --layout-vertical;
        }

        :host > #header {
          @apply --layout-flex-none;
          @apply --layout-self-stretch;
          @apply --layout-horizontal;
          @apply --layout-center;
          background-color: var(--tab-header-bgcolor);
          min-height: var(--tab-header-minheight);
          padding-left:10px;
        }

        :host([dynamic]) > #header {
          padding-left:40px;
        }

        :host > #header > .scroller {
          @apply --layout-flex-none;
          height:16px;
          color: var(--tabitem-active-color);
          cursor:pointer;
          visibility:hidden;
        }

        :host > #header > .scroller.scroll {
          visibility:visible;
        }

        :host > #header > #header-item {
          @apply --layout-flex;
          @apply --layout-self-stretch;
          @apply --layout-horizontal;
          position:relative;
          overflow-x:hidden;
        }

        :host > #header > #header-item > ::slotted([slot=header]) {
          @apply --layout-flex-none;
          @apply --layout-self-stretch;
          padding: 0px 10px;
        }

        :host > #content {
          @apply --layout-flex;
          @apply --layout-self-stretch;
          position:relative;
          background-color: var(--tab-content-bgcolor);
        }

        :host > #content > ::slotted([slot=content]) {
          @apply --layout-fit;
          margin:5px 5px;
          font-family:var(--tab-content-font-family);
          display:none;
        }
        :host > #content > ::slotted(.content-active) {
          display:block;
        }
      </style>
      <div id="header">
        <iron-icon icon="chevron-left" id="pre-scroll" class="scroller" on-tap="_preScroll"></iron-icon>
        <div id="header-item"><slot id="header-slot" name="header"></slot></div>
        <iron-icon icon="chevron-right" id="post-scroll" class="scroller" on-tap="_postScroll"></iron-icon>
      </div>
      <div id="content"><slot name="content"></slot></div>
    `;
  }

  static get properties() {
    return {
      dynamic: {
        type:Boolean,
        value:false,
        reflectToAttribute:true
      }
    };
  }

  ready() {
    super.ready();

    Gestures.addListener(this, "tap", (e)=>{
      let path = e.path || (e.composedPath && e.composedPath());
      let closing = path[0].id=="tab-closer";
      for(let i=0;i<path.length;i++) {
        let el = path[i];
        if(el.nodeName=="BROWN-TABITEM-DESKTOP") {
          if(closing) {//close tabitem
            if(el.active) {//if closing tabitem is active then set other to active
              let other = this._getTabItemSibling(el, null/*no criteria*/);
              if(other) {
                other.active = true;
              }
            }
            let content = this._getContentByDataTab(el.id);
            if(content) {
              this.removeChild(content);
            }
            this.removeChild(el);
          } else {//set tabitem to active
            if( !el.active ) {
              let other = this._getTabItemSibling(el, function(sib){//get active sibling
                return sib.active;//return true if sibling is active
              });//search currently active tabitem
              if(other) {
                other.active = false;//set other to non active
              }
              this._ensureItemVisible(el);
              el.active = true;
            }
          }
          break;
        }
      }
    });

    this.addEventListener("active-changed", (e)=>{
      let content = this._getContentByDataTab(e.target.id);
      if(!content) {
        return;
      }
      if(e.detail.active) {
        content.classList.add("content-active");
      } else {
        content.classList.remove("content-active");
      }
    });

    let slot = this.shadowRoot.querySelector("#header-slot");
    this._observer = new FlattenedNodesObserver(slot, (info) => {
      if(info.addedNodes.length>0 || info.removedNodes.length>0) {
        afterNextRender(this, function() {
          this._evaluateScroll();
        });
      }
    });
  }//ready()

  connectedCallback() {
    super.connectedCallback();
    this._fWndResize = this._fWndResize || this._evaluateScroll.bind(this);
    window.addEventListener("resize", this._fWndResize);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this._fWndResize);
  }

  _getTabItemSibling(el, callback) {
    let sibling;

  //forward
    let element = el;
    while( (sibling = element.nextElementSibling) ) {
      if( sibling.nodeName=="BROWN-TABITEM-DESKTOP" ) {
        if( !callback || callback(sibling) ) {
          return sibling;
        }
      }
      element = sibling;
    }

  //backward
    element = el;
    while( (sibling = element.previousElementSibling) ) {
      if( sibling.nodeName=="BROWN-TABITEM-DESKTOP") {
        if( !callback || callback(sibling) ) {
          return sibling;
        }
      }
      element = sibling;
    }

    return null;
  }//_getTabItemSibling(el, callback)

  _getContentByDataTab(tabId) {
    return this._getLightDOM((el)=>{
      let data = el.nodeName!="BROWN-TABITEM-DESKTOP" ? el.getAttribute("data-tab") : null;
      return tabId==data;
    });
  }

  _getLightDOM(callback) {
    let el = this.firstElementChild;
    while(el) {
      if(callback(el)) {
        return el;
      }
      el = el.nextElementSibling;
    }
    return null;
  }

  _getLightDOMReverse(callback) {
    let el = this.lastElementChild;
    while(el) {
      if(callback(el)) {
        return el;
      }
      el = el.previousElementSibling;
    }
    return null;
  }

  _ensureItemVisible(tabItem) {
    let container = this.shadowRoot.querySelector("#header-item");
    let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
    let left = tabItem.offsetLeft - container.scrollLeft;
    let scroll = 0;
    if( right > container.offsetWidth ) {
      scroll = right - container.offsetWidth;
    } else if( left<0 ) {
      scroll = left;
    }
    if(scroll!=0) {
      container.scrollLeft += scroll;
      this._evaluateScroll();
    }
  }

  _evaluateScroll() {
    setTimeout( ()=>{
      this._evaluateScrollDo("#post-scroll");
      this._evaluateScrollDo("#pre-scroll");
    }, 100);
  }

  _evaluateScrollDo(scrollerId) {
    let container = this.shadowRoot.querySelector("#header-item");
    let scroller = this.shadowRoot.querySelector(scrollerId);
    let visible = false;
    if(scrollerId=="#post-scroll") {
      let tabItem = this._getLightDOMReverse((el)=>{//get last tabItem
        return el.nodeName=="BROWN-TABITEM-DESKTOP";
      });
      if(tabItem) {
        let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
        visible = right > container.offsetWidth;
      }
    } else if(scrollerId=="#pre-scroll") {
      let tabItem = this._getLightDOM((el)=>{//get first tabItem
        return el.nodeName=="BROWN-TABITEM-DESKTOP";
      });
      if(tabItem) {
        let left = tabItem.offsetLeft - container.scrollLeft;
        visible = left < 0;
      }
    }
    if(visible) {
      scroller.classList.add("scroll");
    } else {
      scroller.classList.remove("scroll");
    }
  }

  _preScroll(e) {
    let tabItem = this._getLightDOM((el)=>{//search first tabItem
      return el.nodeName=="BROWN-TABITEM-DESKTOP";
    });
    if(tabItem) {
      let container = this.shadowRoot.querySelector("#header-item");
      let offset = tabItem.offsetLeft - container.scrollLeft;
      if( offset<0 ) {
        offset = Math.max(offset, -1 * (container.offsetWidth/5));
        container.scrollLeft += offset;
        this._evaluateScroll();
      }
    }
  }

  _postScroll(e) {
    let tabItem = this._getLightDOMReverse((el)=>{//search last tabItem
      return el.nodeName=="BROWN-TABITEM-DESKTOP";
    });
    if(tabItem) {
      let container = this.shadowRoot.querySelector("#header-item");
      let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
      let offset = right - container.offsetWidth;
      if( offset>0 ) {
        offset = Math.min(offset, container.offsetWidth/5);
        container.scrollLeft += offset;
        this._evaluateScroll();
      }
    }
  }
}

window.customElements.define('brown-tab-desktop', BrownTabDesktop);
