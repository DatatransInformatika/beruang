import {html, PolymerElement} from '@polymer/polymer/polymer-element.js';
import {GestureEventListeners} from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';
import {FlattenedNodesObserver} from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';
import {afterNextRender} from '@polymer/polymer/lib/utils/render-status.js';
import * as Gestures from '@polymer/polymer/lib/utils/gestures.js';
import '@polymer/iron-flex-layout/iron-flex-layout.js';
import '@webcomponents/shadycss/entrypoints/apply-shim.js';
import {BeruangBehavior} from '@beruang/beruang-behavior.js';
import {BrownBehavior} from '@beruang/brown/brown-behavior.js';
import '@beruang/brown/brown-style.js';

class BrownTabDesktop extends BrownBehavior(BeruangBehavior(GestureEventListeners(PolymerElement))) {
  static get template() {
    return html`
      <style  include="brown-style">
        :host {
          @apply --layout-vertical;
        }

        :host > #header {
          @apply --layout-flex-none;
          @apply --layout-self-stretch;
          @apply --layout-horizontal;
          @apply --layout-center;
          background-color: var(--tab-header-bgcolor);
          min-height: var(--tab-header-minheight);
          padding-left:10px;
        }

        :host([dynamic]) > #header {
          padding-left:40px;
        }

        :host > #header > .scroller {
          @apply --layout-flex-none;
          height:16px;
          color: var(--tabitem-active-color);
          cursor:pointer;
          visibility:hidden;
        }

        :host > #header > .scroller.scroll {
          visibility:visible;
        }

        :host > #header > #header-item {
          @apply --layout-flex;
          @apply --layout-self-stretch;
          @apply --layout-horizontal;
          position:relative;
          overflow-x:hidden;
        }

        :host > #header > #header-item > ::slotted([slot=header]) {
          @apply --layout-flex-none;
          @apply --layout-self-stretch;
          padding: 0px 10px;
        }

        :host > #content {
          @apply --layout-flex;
          @apply --layout-self-stretch;
          position:relative;
          background-color: var(--tab-content-bgcolor);
        }

        :host > #content > ::slotted([slot=content]) {
          @apply --layout-fit;
          margin:5px 5px;
          font-family:var(--tab-content-font-family);
        }

        :host([content='static']) > #content > ::slotted([slot=content]) {
          display:none;
        }

        /*content ada di dlm slot ditampilkan jika ada .content-active*/
        :host([content='static']) > #content > ::slotted(.content-active) {
          display:block;/*membatalkan display none*/
        }
      </style>
      <div id="header">
        <iron-icon icon="chevron-left" id="pre-scroll" class="scroller" on-tap="_preScroll"></iron-icon>
        <div id="header-item"><slot id="header-slot" name="header"></slot></div>
        <iron-icon icon="chevron-right" id="post-scroll" class="scroller" on-tap="_postScroll"></iron-icon>
      </div>
      <div id="content"><slot name="content"></slot></div>
    `;
  }

  static get properties() {
    return {
      dynamic: {
        type:Boolean,
        value:false,
        reflectToAttribute:true
      },

      content: {
        type:String,
        value:"static",/*options: static, dynamic*/
        reflectToAttribute:true
      }
    };
  }

  ready() {
    super.ready();

    Gestures.addListener(this, "tap", (e)=>{
/////////////////////////////memeriksa event tap berasal dari tab-item: START//////////////////
      let path = e.path || (e.composedPath && e.composedPath());
      let tabItem;//tab item tap
      for(let i=0;i<path.length;i++) {//pastikan tap berasal dari tabItem
        let el = path[i];
        if(el.nodeName=="BROWN-TABITEM-DESKTOP") {
          tabItem = el;
          break;
        }
      }
      if(!tabItem) {//tap bukan berasal dari tabtItem, return cepat
        return;
      }
/////////////////////////////memeriksa event tap berasal dari tab-item: END////////////////////

      let closing = path[0].id=="tab-closer";//apakah closing?
      if(closing) {//close tabitem
      //1. pindahkan status aktif ke tabItem lain (jika ada)
        if(tabItem.active) {//if closing tabitem is active then set other to active
          if(this.content=="dynamic") {//hapus content lama
            this._removeDynamicContent();
          }
          let other = this._getTabItemSibling(tabItem, null/*no criteria*/);//cari sibling tanpa periksa aktif atau tidak
          if(other) {//jika ada
            other.active = true;//pindahkan status active ke tabItem lain
          }
        }
      //2. remove content (jika ada)
        if(this.content=="static") {
          let content = this._getContentByDataTab(tabItem.id);//ambil content
          if(content) {//jika ada
            this.removeChild(content);//remove content
          }
        }
      //3. remove tabItem
        this.removeChild(tabItem);//remove tabItem
      } else {
      //aktifkan tab
        if( tabItem.active ) {//tabItem sudah berstatus aktif
          return;//tidak perlu mengaktifkan tabItem
        }
//////////////////////mengatifkan tab, nonaktifkan tab lain: START/////////////////////////////////
      //1. cari tabItem lain yang berstatus aktif, jika ada maka batalkan status aktif
        let callback = (sibling)=>{//callback akan dikirimkan ke fungsi _getTabItemSibling
          return sibling.active==true;//syarat sibling: aktif
        };
        //callback sudah dikirimkan ke fungsi _getTabItemSibling
        let other = this._getTabItemSibling(tabItem, callback);//other -> sibling
        if(other) {
          other.active = false;//matikan tab lain yang statusnya aktif(mengalami _activeChanged)
        }
//////////////////////mengatifkan tab, nonaktifkan tab lain: END///////////////////////////////////

//////////////////////aktifkan tab yang di-klik: START///////////////////////////////////
      //2. pastikan tabItem terlihat seluruhnya, scroll jika perlu
        this._ensureItemVisible(tabItem);
      //3. set status active tabItem menjadi true
        tabItem.active = true;//properti tabitem desktop menjadi aktif(mengalami _activeChanged)
      }
    });
//////////////////////aktifkan tab yang di-klik: END///////////////////////////////////

/////menanggapi event active-changed yang dikirimkan oleh tab item: START///////////////
    this.addEventListener("active-changed", (e)=>{
      let tabItem = e.target;
      if(this.content=="static") {
        let content = this._getContentByDataTab(tabItem.id); //tabItem.id "item1", "item2", "item3", etc...
        if(!content) {//ambil content yg data-tab == tabItem.id
          return;//kalau content tidak ada,langsung keluar dr program
        }
        if(e.detail.active) {
          ///////////e.detail.active == true, tambahkan class content-active dr Index.html
          content.classList.add("content-active");//display:block
        } else {
          ///////////e.detail.active == false, hapus class content-active dr Index.html
          content.classList.remove("content-active");//display:none
        }
      } else if(this.content=="dynamic") {
        if(e.detail.active) {
          this._requestDynamicContent(tabItem.id);
        } else {
          this._removeDynamicContent();
        }
      }
    });
/////menanggapi event active-changed yang dikirimkan oleh tab item: END/////////////////

    let slot = this.shadowRoot.querySelector("#header-slot");//slot -> slot name:header-slot
    let fMonitorCallback = (info) => {//FlattenedNodesObserver memantau slot
      if(info.addedNodes.length>0 || info.removedNodes.length>0) { //jika tab item ditambah atau dihapus
        afterNextRender(this, function() {//beri waktu posisi tab item stabil
          this._evaluateScroll();//perlu tampil scroll kanan, kiri, atau dua-duanya
        });
      }
    };
    this._observer = new FlattenedNodesObserver(slot, fMonitorCallback);
  }//ready()

  connectedCallback() {
    super.connectedCallback();
    this._fWndResize = this._fWndResize || this._evaluateScroll.bind(this);
    window.addEventListener("resize", this._fWndResize);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this._fWndResize);
  }

////////////////////////fungsi untuk menggeser tab lain (next / previous), jika suatu tab ditutup:START/////////////
  _getTabItemSibling(el/*tab item*/, callback/*fungsi berisi syarat pencarian*/) {
    let f = (sib)=>{
      return sib.nodeName=="BROWN-TABITEM-DESKTOP" && //syarat 1: sibling harus <brown-tab-desktop></brown-tab-desktop>
        ( !callback || callback(sib) ); //syarat 2: jika tidak ada callback atau
                                                  //callback return true, maka sibling memenuhi syarat
    };
    let sibling = this._getLightDOM(el.nextElementSibling, true, f); //forward
    if(!sibling) {
      sibling = this._getLightDOM(el.previousElementSibling, false, f); //backward
    }
    return sibling;
  }//_getTabItemSibling(el, callback)
  ////////////////////////fungsi untuk menggeser tab lain (next / previous), jika suatu tab ditutup:END/////////////


  _removeDynamicContent() {//hanya ada satu div content jika content=="dynamic"
    let fCheck = (el)=>{
      return el.slot == "content";
    };
    let content = this._getLightDOM(this.firstElementChild, true, fCheck);
    if(content) {
      this.removeChild(content);
    }
  }

  _requestDynamicContent(id) {
    let fDecorator = (el)=>{
      el.slot="content";
    };
    this.dispatchEvent(
      new CustomEvent(
        "dynamic-content",//konstruksi event argument 1: nama event
        { bubbles:true,
          composed:true,
          //mengambil anggota active dari event: event.detail.active;
          detail:{"id":id, tab:this, decorator:fDecorator}//event "active-changed" mengirim newValue
        }//konstruksi event argument 2: object event
      )
    );
  }

  _getContentByDataTab(tabId) {
    return this._getLightDOM(this.firstElementChild, true, (el)=>{
      let data = el.nodeName!="BROWN-TABITEM-DESKTOP" ? el.getAttribute("data-tab") : null;
      return tabId==data;
    });
  }

  _getLightDOM(startEl, forward, callback) {
    let el = startEl;
    while(el) {
      if(callback(el)) {
        return el;
      }
      el = forward ? el.nextElementSibling : el.previousElementSibling;
    }
    return null;
  }

  _ensureItemVisible(tabItem) {
    let container = this.shadowRoot.querySelector("#header-item");
    let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
    let left = tabItem.offsetLeft - container.scrollLeft;
    let scroll = 0;
    if( right > container.offsetWidth ) {
      scroll = right - container.offsetWidth;
    } else if( left<0 ) {
      scroll = left;
    }
    if(scroll!=0) {
      container.scrollLeft += scroll;
      this._evaluateScroll();
    }
  }

  _evaluateScroll() {
    setTimeout( ()=>{
      this._evaluateScrollDo("#post-scroll");
      this._evaluateScrollDo("#pre-scroll");
    }, 100);
  }

  _evaluateScrollDo(scrollerId) {
    let container = this.shadowRoot.querySelector("#header-item");
    let scroller = this.shadowRoot.querySelector(scrollerId);
    let visible = false;
    if(scrollerId=="#post-scroll") {
      let tabItem = this._getLightDOM(this.lastElementChild, false, (el)=>{//get last tabItem
        return el.nodeName=="BROWN-TABITEM-DESKTOP";
      });
      if(tabItem) {
        let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
        visible = right > container.offsetWidth;
      }
    } else if(scrollerId=="#pre-scroll") {
      let tabItem = this._getLightDOM(this.firstElementChild, true, (el)=>{//get first tabItem
        return el.nodeName=="BROWN-TABITEM-DESKTOP";
      });
      if(tabItem) {
        let left = tabItem.offsetLeft - container.scrollLeft;
        visible = left < 0;
      }
    }
    if(visible) {
      scroller.classList.add("scroll");
    } else {
      scroller.classList.remove("scroll");
    }
  }

  _preScroll(e) {
    let tabItem = this._getLightDOM(this.firstElementChild, true, (el)=>{//search first tabItem
      return el.nodeName=="BROWN-TABITEM-DESKTOP";
    });
    if(tabItem) {
      let container = this.shadowRoot.querySelector("#header-item");
      let offset = tabItem.offsetLeft - container.scrollLeft;
      if( offset<0 ) {
        offset = Math.max(offset, -1 * (container.offsetWidth/5));
        container.scrollLeft += offset;
        this._evaluateScroll();//selesai scroll, diperiksa masih butuh scroll atau tidak
      }
    }
  }

  _postScroll(e) {
    let tabItem = this._getLightDOM(this.lastElementChild, false, (el)=>{//search last tabItem
      return el.nodeName=="BROWN-TABITEM-DESKTOP";
    });
    if(tabItem) {
      let container = this.shadowRoot.querySelector("#header-item");
      let right = tabItem.offsetLeft + tabItem.offsetWidth - container.scrollLeft;
      let offset = right - container.offsetWidth;
      if( offset>0 ) {
        offset = Math.min(offset, container.offsetWidth/5);
        container.scrollLeft += offset;
        this._evaluateScroll();//selesai scroll, diperiksa masih butuh scroll atau tidak
      }
    }
  }
}

window.customElements.define('brown-tab-desktop', BrownTabDesktop);
