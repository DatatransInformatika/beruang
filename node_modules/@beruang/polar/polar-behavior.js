import {dedupingMixin} from '@polymer/polymer/lib/utils/mixin.js';
import {FlattenedNodesObserver} from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';

let internalPolarBehavior = (base) =>
class extends base {
	static get properties() {
		return {
			noWrap: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowXVisible: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowXHidden: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowXScroll: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowXAuto: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowYVisible: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowYHidden: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowYScroll: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			overflowYAuto: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			alignStart: {
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			alignEnd:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			alignCenter:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},
		
			alignSpaceBetween:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			alignSpaceAround:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			crossAlignStart:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},
					
			crossAlignEnd:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			crossAlignCenter:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			crossAlignStretch:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			},

			crossAlignBaseline:{
				type: Boolean,
				value: false,
				reflectToAttribute: true
			}
    	};
	}

	connectedCallback() {
		super.connectedCallback();
		let slot = this.shadowRoot.querySelector("slot");
		this._observer = new FlattenedNodesObserver(slot, (info)=>{
			for(let i=0;i<info.addedNodes.length;i++) {
				if(info.addedNodes[i].nodeType==1) {
					this._flex(info.addedNodes[i]);
					this._selfAlign(info.addedNodes[i]);
				}
			}
		});
	}

	disconnectedCallback() {
		super.disconnectedCallback();
		this._observer.disconnect();
	}

	_flex(el) {
		let style = "flex-auto";
		let num;
		let flex = el.getAttribute("data-flex");
		switch(flex){
			case "none":
				style = "flex-none";
				break;
			case "auto":
				style = "flex-auto";
				break;
			default:
				num = parseInt(flex, 10);
				if( !isNaN(num) && num>=1 && num<=10) {
					style = "flex-" + num;
				}
				break;
		}
		el.classList.add(style);
	}

	_selfAlign(el) {
		let align = el.getAttribute("data-self-align");
		switch(align){
			case "start":
			case "end":
			case "center":
			case "stretch":
			case "baseline":
				el.classList.add("self-align-" + align);
				break;
			default:
				break;
		}
	}
}

export const PolarBehavior = dedupingMixin(internalPolarBehavior);
